<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>You Describe</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

    <script src="https://www.youtube.com/iframe_api"></script>
  </head>
  <body>
    <h1>Upload audio</h1>
    <button id="record">Record</button>
    <div id="messages"></div>

<script>

function mergeBuffers(channelBuffer, recordingLength){
  var result = new Float32Array(recordingLength);
  var offset = 0;
  var lng = channelBuffer.length;
  for (var i = 0; i < lng; i++){
    var buffer = channelBuffer[i];
    result.set(buffer, offset);
    offset += buffer.length;
  }
  return result;
}

function interleave(leftChannel, rightChannel){
  var length = leftChannel.length + rightChannel.length;
  var result = new Float32Array(length);
 
  var inputIndex = 0;
 
  for (var index = 0; index < length; ){
    result[index++] = leftChannel[inputIndex];
    result[index++] = rightChannel[inputIndex];
    inputIndex++;
  }
  return result;
}

function writeUTFBytes(view, offset, string){ 
  var lng = string.length;
  for (var i = 0; i < lng; i++){
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

function permissionToAccessMediaDeviceGranted(e) {
    $('#messages').append('Media device access permission granted!');

    // creates the audio context
    audioContext = window.AudioContext || window.webkitAudioContext;
    context = new audioContext();

    // retrieve the current sample rate to be used for WAV packaging
    sampleRate = context.sampleRate;

    // creates a gain node
    volume = context.createGain();

    // creates an audio node from the microphone incoming stream
    audioInput = context.createMediaStreamSource(e);

    // connect the stream to the gain node
    audioInput.connect(volume);

    /* From the spec: This value controls how frequently the audioprocess event is 
    dispatched and how many sample-frames need to be processed each call. 
    Lower values for buffer size will result in a lower (better) latency. 
    Higher values will be necessary to avoid audio breakup and glitches */
    var bufferSize = 2048;
    recorder = context.createJavaScriptNode(bufferSize, 2, 2);

    recorder.onaudioprocess = function(e){
        console.log ('recording');
        // var left = e.inputBuffer.getChannelData (0);
        // var right = e.inputBuffer.getChannelData (1);
        // // we clone the samples
        // leftchannel.push (new Float32Array (left));
        // rightchannel.push (new Float32Array (right));
        // recordingLength += bufferSize;
    }

    // we connect the recorder
    volume.connect (recorder);
    recorder.connect (context.destination); 
}

function getUserPermissionToAccessMediaDevice() {
  if (!navigator.getUserMedia) {
    navigator.getUserMedia  = navigator.getUserMedia ||
                              navigator.webkitGetUserMedia ||
                              navigator.mozGetUserMedia ||
                              navigator.msGetUserMedia;
  }

  if (navigator.getUserMedia) {
    navigator.getUserMedia({ audio: true }, permissionToAccessMediaDeviceGranted, (e) => {
      $('#messages').append('Error capturing audio!');
    })
  } else {
    $('#messages').append('getUserMedia not supported!');
  }
}

$(function() {
  $('#record').click(function() {
    getUserPermissionToAccessMediaDevice();
  });
});

// // we flat the left and right channels down
// var leftBuffer = mergeBuffers ( leftchannel, recordingLength );
// var rightBuffer = mergeBuffers ( rightchannel, recordingLength );
// // we interleave both channels together
// var interleaved = interleave ( leftBuffer, rightBuffer );
 
// // create the buffer and view to create the .WAV file
// var buffer = new ArrayBuffer(44 + interleaved.length * 2);
// var view = new DataView(buffer);
 
// // write the WAV container, check spec at: https://ccrma.stanford.edu/courses/422/projects/WaveFormat/
// // RIFF chunk descriptor
// writeUTFBytes(view, 0, 'RIFF');
// view.setUint32(4, 44 + interleaved.length * 2, true);
// writeUTFBytes(view, 8, 'WAVE');
// // FMT sub-chunk
// writeUTFBytes(view, 12, 'fmt ');
// view.setUint32(16, 16, true);
// view.setUint16(20, 1, true);
// // stereo (2 channels)
// view.setUint16(22, 2, true);
// view.setUint32(24, sampleRate, true);
// view.setUint32(28, sampleRate * 4, true);
// view.setUint16(32, 4, true);
// view.setUint16(34, 16, true);
// // data sub-chunk
// writeUTFBytes(view, 36, 'data');
// view.setUint32(40, interleaved.length * 2, true);
 
// // write the PCM samples
// var lng = interleaved.length;
// var index = 44;
// var volume = 1;
// for (var i = 0; i < lng; i++){
//     view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
//     index += 2;
// }
 
// // our final binary blob that we can hand off
// var blob = new Blob ( [ view ], { type : 'audio/wav' } );

// function upload(blobOrFile) {
//   var xhr = new XMLHttpRequest();
//   xhr.open('POST', './upload.php', true);
//   xhr.onload = function(e) {};
//   // Listen to the upload progress.
//   // assuming you have a progress element on your dom
//   var progressBar = document.querySelector('progress');
//   xhr.upload.onprogress = function(e) {
//     if (e.lengthComputable) {
//       progressBar.value = (e.loaded / e.total) * 100;
//       progressBar.textContent = progressBar.value; // Fallback for unsupported browsers.
//     }
//   };
 
//   xhr.send(blobOrFile);
// }
</script>









    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  </body>
</html>
